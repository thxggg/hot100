### 第一阶段：暴力解法（Brute Force） - O(n²)

- **核心思路**：最直观、最符合人类本能的想法——**“挨个试”**。
  1. 拿起第一个数。
  2. 用它和**后面所有**的数，一个个地加起来，看等不等于 `target`。
  3. 如果第一个数不行，就拿起第二个数，重复上面的过程。
- **实现方式**：这个思路很自然地就对应了**两个嵌套的 `for` 循环**。外层循环负责“拿起”一个数，内层循环负责“挨个试”剩下的数。
- **我们遇到的问题和学到的知识点**：
  1. **返回类型错误**：你一开始写了 `return i, j;`。这是一个常见的语法错误。我们学到了，在 C++ 中，如果函数声明要返回 `vector<int>`，你就必须返回一个符合该类型的对象，正确的写法是 `return {i, j};`。
  2. **编译器检查所有路径**：当 `return` 语句只在 `if` 内部时，编译器会报错 `non-void function does not return a value in all control paths`。我们学到了，编译器不理解题目的“一定有解”这个保证，它只检查代码逻辑。所以我们需要在函数末尾加上一个“兜底”的返回值，比如 `return {};`，来安抚编译器。
  3. **时间复杂度**：因为是两层循环，每个数都需要和其它 `n-1` 个数进行比较，所以总的计算量大约是 n * n，时间复杂度就是 O(n²)。对于大数据量，这个方法会非常慢。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        for(int i = 0; i < nums.size(); i++)
        {
            for(int j = 0; j < nums.size(); j++)
            {
                if(nums[i] + nums [j] == target && i != j)
                {
                    return {i, j};
                }
            }
        }
        return {};
    }
};
```

----

### 第二阶段：哈希表优化 - O(n)

- **思路的飞跃**：我们意识到，暴力解法的“慢”，就慢在了**“寻找搭档”**这一步。内层循环 O(n) 的查找效率太低了。于是我们问自己：**有没有什么数据结构能让我们瞬间（O(1)）查到一个数是否存在？**
- **你的关键洞察**：你准确地想到了 **`map`**（哈希表）！
- **我们遇到的问题和学到的知识点**：
  1. **`map` 里存什么？**：
     - 你最初的想法是“位置是键，值是值”（`key: index, value: num`）。我们一起分析后发现，这样还是无法快速通过“值”来找到“位置”。
     - 于是我们得到了正确的方案：**“值是键，位置是值”** (`key: num, value: index`)。这样我们就能通过一个数字，瞬间查到它的位置。这是这道题最核心的知识点。
  2. **两遍遍历 vs 一遍遍历**：
     - 一开始我们想的实现是：先用一个循环把所有数存入 `map`，再用第二个循环去遍历数组，在 `map` 中找搭档。这个方法是可行的，但需要两个独立的循环。
     - 后来我们进一步优化，发现可以在**一个循环内同时完成“查找”和“存入”**。
  3. **“先查再存”的逻辑顺序**：
     - 你写的最后那版代码，一开始是“先存再查”，我们发现用 `[3, 3], target=6` 这个例子测试时会出问题，因为它会找到自己。
     - 最终我们确定了最优的逻辑顺序：**先去 `map` 里找搭档，如果找不到，再把自己存进去给后面的人用。** 这样就完美避免了找到自己的问题，代码也更简洁，连 `i != number[partner]` 那个判断都可以省掉。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int, int> number;
        for(int i = 0; i < nums.size(); i++)
        {
            
            int partner = target - nums[i];
            if(number.count(partner))
            {
                return {i, number[partner]};
            }
            number[nums[i]] = i;
        }
        return {};
    }
};
```



------

### 总结

从 O(n²) 到 O(n)，关键在于我们**用空间换取了时间**。我们额外使用了一个 `map` 的空间，把查找搭档这个操作从 O(n) 的“地毯式搜索”变成了 O(1) 的“精确制导”，从而让整个算法的效率发生了质的飞跃。



