

### 第一阶段：直观解法 - 排序 O(n log n)

- **核心思路**：面对一个乱序的数组，最自然的想法就是先把它变整齐。你第一时间就想到了**排序**。
- **遇到的困惑与解惑**：你提出了一个非常好的问题：“排序会不会把序列打乱？”。我们通过分析题目“不要求序列元素在原数组中连续”这句话，明确了我们要找的是**数值上**的连续，而排序恰恰能帮助我们把数值上连续的数聚集在一起。
- **算法流程**：
  1. 对原数组进行排序。
  2. 遍历排序后的数组，用一个 `current_streak` 变量记录当前连续长度，用 `longest_streak` 记录最大长度。
  3. 通过比较 `nums[i+1]` 和 `nums[i]` 的关系来更新 `current_streak`。
- **为什么这不是最终答案**：因为常规排序算法的时间复杂度是 O(n log n)，不满足题目 O(n) 的要求。但这仍然是一个非常重要的、能解决问题的思路。

### 第二阶段：最优解法 - 哈希集合 O(n)

- **思路的飞跃**：我们意识到，为了达到 O(n)，就不能排序。那么问题就变成了：如何在乱序的数组里高效地**查找**一个数的“邻居”？
- **你的关键洞察**：你再次准确地想到了**哈希表**！这说明你已经能熟练地运用这个工具来优化查找效率了。在这里，因为只关心数存不存在，所以我们用了更精确的**哈希集合 (`unordered_set`)**。
- **算法的核心与难点**：
  1. **准备工作**：先用一个循环，把所有数字都放进哈希集合，为 O(1) 的快速查找做准备。
  2. **关键优化 - “寻找龙头”**：这是整个算法最巧妙的地方。为了避免对一个序列（如 `1,2,3,4`）反复计算（从2数一遍，又从3数一遍），我们约定只从一个序列的**开头**（我们称之为“龙头”）开始数。
  3. **如何判断“龙头”**：你准确地得出了判断方法——如果一个数 `num` 的前一个数 `num - 1` **不存在**于哈希集合中，那么 `num` 就是一个“龙头”。
  4. **计算序列长度**：一旦找到龙头，就用一个 `while` 循环不断地 `+1` 查找下去（`num+1`, `num+2`...），直到找到序列的末尾，从而计算出当前序列的长度。
  5. **更新最大值**：和全局的 `longest_streak` 比较并更新。
- **调试与完善**：我们最后遇到了 `[1,0,1,2]` 这个测试用例，预期结果是3（`0,1,2`），但输出是1。这说明代码在实现“计算序列长度”这步时可能出了问题。正确的实现应该是在找到龙头 `0` 之后，通过 `while` 循环发现 `1` 和 `2` 也在集合中，从而算出 `current_streak` 为3，并更新 `longest_streak`。

### 总结

这道题我们从 O(n log n) 的排序法，最终走到了 O(n) 的哈希集合法。核心是**再次利用哈希结构优化了查找效率**，并通过“寻找龙头”这一聪明技巧，避免了重复计算，从而将整体时间复杂度控制在了 O(n)。

```cpp 
#include <unordered_set>
#include <algorithm> 

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if (nums.empty()) {
            return 0; 
        }

        unordered_set<int> num_set(nums.begin(), nums.end());
        int longest_streak = 0;

        for (int num : num_set) { 
            if (num_set.count(num - 1) == 0) { 
                
                int current_num = num;
                int current_streak = 1;

                while (num_set.count(current_num + 1)) {
                    current_num += 1;
                    current_streak += 1;
                }
                
                longest_streak = max(longest_streak, current_streak);
            }
        }

        return longest_streak;
    }
};
```

