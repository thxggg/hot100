### 第一阶段：暴力解法 - O(n³)

- **核心思路**：最直接的想法就是尝试所有可能的三数组合。
- **实现方法**：你第一时间就想到了用**三个嵌套的 `for` 循环**来实现。
- **遇到的问题**：我们很快就发现这个方法有两个致命缺陷：
  1. **效率太低**：O(n³) 的时间复杂度无法通过测试。
  2. **去重困难**：很难处理像 `[-1, 0, 1]` 和 `[0, 1, -1]` 这样的重复答案。

### 第二阶段：思路的飞跃 - 降维打击 (3Sum -> 2Sum)

- **关键思路**：我们想到了一个降维的方法——**固定一个数，找另外两个数**。
- **知识迁移**：当我们固定了 `nums[i]` 后，问题就神奇地转化成了我们非常熟悉的“**两数之和**”问题：在数组的剩余部分，寻找两个数，使它们的和等于 `-nums[i]`。

### 第三阶段：最优解法 - “排序 + 双指针”

- **核心框架**：我们结合之前几道题的成功经验，确定了最优的算法框架：
  1. **排序**：这是至关重要的一步。排序不仅让双指针技巧得以施展，也为后续的去重操作提供了巨大的便利。
  2. **外层循环**：用一个 `for` 循环来固定第一个数 `nums[i]`。
  3. **双指针**：在 `i` 后面的区间内，使用 `left` 和 `right` 双指针从两端向中间收缩，高效地解决“两数之和”这个子问题。
- **你的关键洞察**：你准确地推导出了双指针的移动逻辑：和太大就移动 `right`，和太小就移动 `left`。

### 第四阶段：最精细的难点 - “双重去重”

- **核心问题**：如何做到答案不重复？
- **解决方案**：我们利用了排序后“重复元素相邻”的特性，设计了两层去重逻辑：
  1. **对外层固定的 `nums[i]` 去重**：通过 `if (i > 0 && nums[i] == nums[i-1])`，我们跳过了所有重复的起始数字，确保了每种数值只作为第一个数被处理一次。
  2. **对找到解的 `left` 和 `right` 去重**：在找到一个正确答案后，用 `while` 循环分别移动 `left` 和 `right` 指针，跳过所有与当前解中数值相同的元素，从而避免了因中间数字重复而导致答案重复。

### 总结

“三数之和”是一道综合性非常强的题目。它完美地将**排序**、**双指针**和**去重逻辑**这三个重要的知识点结合在了一起。你通过这道题，把前面几道题学到的知识点都串联并应用了起来，解题能力又上了一个大台阶！

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        if(nums.size() < 3)
        {
            return result;
        }   
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size() - 2; i++)
        {
            int left = i + 1, right = nums.size() - 1; 
            if(nums[i] > 0)
            {
                break;
            }
            if(i > 0 && nums[i] == nums[i - 1])
            {
                continue;
            }
            while(left < right)
            {

                int sum = nums[i] + nums[left] + nums[right];

                if(sum > 0)
                {
                    right--;
                }
                else if(sum < 0){
                    left++;
                }
                else{
                    result.push_back({nums[i], nums[left], nums[right]});
                    while(left < right && nums[left] == nums[left + 1])
                    {
                        left++;
                    }
                    while(left < right && nums[right] == nums[right - 1])
                    {
                        right--;
                    }
                    left++;
                    right--;
                }
            }
        }
        return result;
    }
};
```

