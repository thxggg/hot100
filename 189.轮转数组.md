### 解法一：使用新数组 (O(n) 时间, O(n) 空间)

- **核心思路**：最直观的方法，用空间换取逻辑的简单性。
- **实现方法**：创建一个新的临时数组，通过数学公式 `new_index = (i + k) % n` 直接计算出每个元素旋转后的最终位置，然后将元素放入新数组，最后再把新数组的内容复制回原数组。
- **优点**：逻辑非常直接，容易理解和实现。
- **缺点**：使用了 O(n) 的额外空间，不满足进阶要求。

### 解法二：暴力旋转 k 次 (O(n*k) 时间, O(1) 空间)

- **核心思路**：完全模拟旋转的过程，转一次、再转一次……一共转 `k` 次。
- **实现方法**：我们把问题分解成“如何原地旋转1步”，并通过“先暂存最后一个元素，再将前面所有元素右移，最后将暂存的元素放回头位”的方式实现。然后将这个操作重复 `k` 次。
- **优点**：实现了 O(1) 空间复杂度的原地操作。
- **缺点**：你准确地分析出它的时间复杂度是 O(n*k)，当 `k` 和 `n` 都很大时，会严重超时。

### 解法三：三次反转法 (O(n) 时间, O(1) 空间)

- **核心思路**：这是本题最巧妙、最高效的“脑筋急转弯”式解法。它将一个复杂的“旋转”操作，分解成了三次简单的“反转”操作。
- **实现方法**：我们一起通过实例验证了它的神奇之处：
  1. **全局反转**：将整个数组全部反转。
  2. **局部反转1**：只反转前 `k` 个元素。
  3. **局部反转2**：只反转后面 `n-k` 个元素。
- **优点**：完美地同时满足了 O(n) 时间复杂度和 O(1) 空间复杂度的要求。
- **代码实现**：我们学习了如何使用 C++ 标准库中的 `std::reverse` 函数来方便地对数组的任意区间进行反转，让代码变得极其简洁。

### 总结

这道题是一次非常棒的思维锻炼。它让我们看到，同一个问题可以有多种解法，从最直观的暴力模拟，到用空间换时间，再到不借助额外空间、通过巧妙的数学/逻辑变换（三次反转）来达到最优解。你不仅找到了这三种方法，还最终写出了最高效、最巧妙的一种，非常棒！

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin() + k);
        reverse(nums.begin() + k, nums.end());
    }
};
```

