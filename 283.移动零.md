### 第一阶段：核心思路 - 双指针“分离”法

- **核心问题**：如何在保持非零数相对顺序不变的前提下，把零都“赶”到后面去？
- **关键思路**：我们没有去想怎么“移动0”，而是反过来想怎么“放置非零数”。这引出了**“双指针”**这个强大的技巧。我们把数组想象成两个区域：已处理好的“非零区”和待处理的“未知区”。
- **两个指针的分工**：
  - **快指针 `i`**：我们把它比作“侦察兵”，它的任务是勇往直前，遍历整个数组，探查每一个元素。
  - **慢指针 `j`**：我们把它比作“工兵”，它的任务是守在“非零区”的边界线上，标记着下一个非零数应该被放置的位置。

### 第二阶段：操作方法的选择与优化

- **核心问题**：当“侦察兵”`i` 找到了一个非零数，应该如何处理？
- **你的关键洞察**：你非常敏锐地想到了**“交换” (`swap`)**。这是一个非常棒的想法，因为它一步操作就完成了两件事：
  1. 把非零数放到了它该去的位置（`j` 指向的“非零区”边界）。
  2. 把一个0（或者一个还没来得及处理的非零数）换到了后面。
- **为什么“交换”是优解**：这个方法正好满足了题目的进阶要求——“尽量减少操作次数”。相比于另一种“覆盖”方法（先把所有非零数挪到前面，再把数组末尾全部填0），交换法通常涉及更少的写操作。

### 第三阶段：代码实现与关键知识点

- **算法流程**：我们最终确定了清晰的算法：
  1. `i` 和 `j` 从0开始。
  2. `i` 遍历数组，如果 `nums[i]` 非零，就和 `nums[j]` 交换，然后 `j` 前进一格 (`j++`)。
  3. 如果 `nums[i]` 是零，`j` 不动，只有 `i` 继续前进。
- **我们遇到的问题和学到的知识点**：
  1. **逻辑细节**：我们明确了 `j` 只有在成功安置了一个非零数之后才会移动，它的移动代表着“非零区”的扩张。
  2. **C++ 关键概念**：你的代码逻辑完全正确，但遇到了一个编译错误。这让我们学到了一个重要的 C++ 知识点：`void` 返回类型和引用传递 (`&`)。我们明白了，当函数被声明为 `void` 并且通过引用修改参数时，函数本身不需要（也不能）有 `return` 语句。

### 总结

这道题让我们深入实践了**双指针技术**。通过为两个指针设定不同的职责（一个探索，一个定位），我们仅用一次遍历就原地解决了问题，达到了 O(n) 的时间复杂度和 O(1) 的空间复杂度。

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int j = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] != 0)
            {
                swap(nums[i], nums[j]);
                j++;
            }
        }
    }
};
```

