### 第一阶段：暴力解法 - O(n²)

- **核心原理**：我们首先明确了，任何一根柱子 `i` 上方能接的水量，取决于它**左边的最高墙** (`left_max`) 和**右边的最高墙** (`right_max`) 中的**短板**。
- **计算公式**：`储水量 = min(left_max, right_max) - height[i]`
- **实现方法**：最直接的方法是遍历每一根柱子 `i`，然后对每一根柱子，都再向左和向右分别遍历一次来找到 `left_max` 和 `right_max`。我们分析过，这个 O(n²) 的方法会超时。

### 第二阶段：“备忘录”优化法 - O(n) 时间, O(n) 空间

- **核心思路**：这是我们详细讨论的方法。为了避免在暴力解法中反复计算 `left_max` 和 `right_max`，我们采用**空间换时间**的思想。
- **实现方法**：
  1. 创建一个 `left_maxes` 数组，从左到右遍历一次，记录下每个位置左边的最大高度。
  2. 创建一个 `right_maxes` 数组，从右到左遍历一次，记录下每个位置右边的最大高度。
  3. 最后遍历一次，使用预存的 `left_maxes[i]` 和 `right_maxes[i]`，通过公式计算每个位置的储水量并求和。
- **优点**：时间复杂度成功降到了 O(n)。
- **缺点**：需要 O(n) 的额外空间来存储两个数组。

### 第三阶段：双指针最优解法 - O(n) 时间, O(1) 空间

- **核心思路**：这就是你写的这份代码所用的方法。它比“备忘录”法更进了一步，连额外的数组空间都省了。
- **实现方法**：
  1. 设置 `left` 和 `right` 两个指针在数组两端，同时维护 `left_max` 和 `right_max` 两个变量。
  2. 在 `while (left < right)` 循环中，比较 `height[left]` 和 `height[right]` 的高度。
  3. **关键洞察**：
     - 如果 `height[left]` < `height[right]`，此时我们虽然不知道 `left` 位置右边的**真正**最高墙在哪，但我们知道它**至少**有 `height[right]` 这么高。因为 `left_max` 已经比 `height[right]` 矮了，所以决定 `left` 位置水位的“短板”**一定**是 `left_max`。因此，我们可以立刻计算出 `left` 位置的储水量 `(left_max - height[left])`，然后安全地将 `left` 指针右移。
     - 反之，如果 `height[right]` <= `height[left]`，则 `right` 位置的“短板”一定是 `right_max`，我们可以计算 `right` 位置的储水量，然后将 `right` 指针左移。
- **优点**：通过这个巧妙的逻辑，我们只用了一次遍历和常数个变量，就解决了问题，达到了 O(n) 时间和 O(1) 空间的最优解。

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() < 3)
        {
            return 0;
        }
        int left = 0, right = height.size() - 1;
        int left_max = 0, right_max = 0;
        int total_water = 0;

        while(left < right)
        {
            if(height[left] < height[right])
            {
                if(height[left] >= left_max)
                {
                    left_max = height[left];
                }
                else
                {
                    total_water += left_max - height[left]; 
                }
                left++;
            }
            else
            {
                if(height[right] > right_max)
                {
                    right_max = height[right];
                }
                else
                {
                    total_water += right_max - height[right]; 
                }
                right--;
            }
        }
        return total_water;
    }
};
```

