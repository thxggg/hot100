### 第一阶段：思路的建立 (知识迁移)

- **核心问题**：如何判断一个子串是 `p` 的“异位词”？
- **关键思路**：你立刻就想到了我们之前做“字母异位词分组”的经验。我们探讨了两种判断方法：
  1. **排序法**：将子串排序后看是否与排序后的 `p` 相等。我们分析后发现，对每个子串都进行排序，效率太低，会超时。
  2. **哈希表计数法**：判断两个字符串的“字符账单”（每种字符的数量）是否完全一样。我们一致认为这个方法更适合“滑动”的场景。

### 第二阶段：核心算法 - “滑动窗口”

- **思路的飞跃**：我们没有选择暴力地检查每一个子串，而是采用了**滑动窗口**的技巧。这个技巧的精髓在于，当窗口向右移动一格时，我们**不需要重新计算整个窗口**，只需要更新变化的部分。
- **“双账单”模型**：我们把这个过程比作维护两个账单：
  - 一个**固定**的 `p_map`（`p` 的字符账单）。
  - 一个**动态**的 `window_map`（当前窗口的字符账单）。
- **算法流程**：
  1. **初始化**：先建立 `p_map` 和第一个窗口的 `window_map`。
  2. **滑动**：用一个 `for` 循环，模拟窗口向右滑动。每次滑动：
     - 将**新进入**的字符数量在 `window_map` 中**加一**。
     - 将**刚离开**的字符数量在 `window_map` 中**减一**。
  3. **比较**：每次滑动后，都比较 `p_map` 和 `window_map` 是否完全相等。如果相等，就记录下当前窗口的起始位置。

### 第三阶段：代码实现与细节调试

- 这是本次解题最有价值的部分之一。在你的编码过程中，我们一起解决了几个非常经典和常见的细节问题：
  1. **下标错误**：在记录答案时，应该使用代表窗口起始位置的 `left` 指针，而不是循环变量。
  2. **类型错误**：向 `vector<int>` 中添加了字符串 `"0"`，我们修正为了整数 `0`。
  3. **Map 比较的陷阱**：这是最微妙的bug。我们发现，当 map 中一个字符的数量被减为0时，这个 `{字符: 0}` 的条目并不会自动消失，这会导致 map 的比较失败。最终的解决方法是，当数量为0时，就用 `.erase()` 将其彻底移除。

### 总结

这道题是你到目前为止解决的最复杂的问题，它完美地展示了一个**固定大小的滑动窗口**算法。它不仅巩固了你对**哈希表计数**的理解，更通过动手调试，让你掌握了在实现复杂算法时需要注意的各种细节。

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int s_len = s.length();
        int p_len = p.length();
        
        if (s_len < p_len) {
            return {};
        }
        
        map<char, int> p_map;
        map<char, int> windows_map;
        vector<int> result;

        for(int i = 0; i < p.length(); i++)
        {
            p_map[p[i]]++;
        }
        for(int i = 0; i < p.length(); i++)
        {
            windows_map[s[i]]++;
        }

        if(p_map == windows_map)
        {
            result.push_back(0);
        }
        int left = 0;
        for(int right = p.length(); right < s.length(); right++)
        {
            windows_map[s[left]]--;
            if (windows_map[s[left]] == 0) {
                windows_map.erase(s[left]);
            }
            windows_map[s[right]]++;
            left++;
            if(p_map == windows_map)
            {
                result.push_back(left);
            }
        }
        return result;
    }
};
```

