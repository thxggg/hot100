### 第一阶段：暴力解法 - O(n²)

- **核心思路**：最直观的方法就是找出所有可能的连续子数组，计算它们的和，然后找到最大值。
- **实现方法**：你很快就确定了这需要**两个嵌套的 `for` 循环**，一个定起点，一个定终点。
- **遇到的瓶颈**：我们也立刻达成共识，O(n²) 的时间复杂度对于 `10^5` 级别的数据量来说太慢了，一定会超时。这促使我们必须寻找一个只遍历一次的 O(n) 解法。

### 第二阶段：最优解法 - 动态规划 O(n)

- **思路的飞跃**：我们改变了思考问题的角度。不再去枚举所有的子数组，而是提出了一个动态规划的问题：当我们遍历到 `i` 位置时，**以 `nums[i]` 为结尾的连续子数组的最大和是多少？**
- **关键洞察**：对于 `nums[i]`，它只有两个选择：
  1. **自立门户**：自己单独成为一个新的子数组的开头。
  2. **加入组织**：加入到以 `nums[i-1]` 结尾的那个子数组中。
- **你的核心推导**：你准确地推导出了决策的关键——看前面的“积累”是“资产”还是“包袱”。
  - 如果以 `nums[i-1]` 结尾的子数组的和（`current_sum`）是**负数**，那它就是个“包袱”，我们应该果断抛弃它，让 `nums[i]` 自立门户。
  - 如果是**正数或零**，那它就是“资产”，应该让 `nums[i]` 加入进来，让和继续增长。
- **逻辑升华**：我们把这个逻辑提炼成了一个非常优雅的数学表达式：`current_sum = max(nums[i], current_sum + nums[i])`。

### 第三阶段：代码实现与全局最优

- **算法流程**：我们最终确定了完整的算法：
  1. 初始化**当前和** `current_sum` 和**最大和** `max_sum` 为第一个元素。
  2. 从第二个元素开始遍历数组。
  3. 在循环的每一步，先用上面的公式更新 `current_sum`。
  4. 然后，你准确地指出了还需要一步——用更新后的 `current_sum` 去挑战并可能地更新全局的 `max_sum`：`max_sum = max(max_sum, current_sum)`。
- **最终代码**：你写的最终代码完美地实现了这个流程，简洁且高效。

### 总结

这道题是动态规划思想的绝佳入门范例。它的核心在于，当前的状态只依赖于前一个状态，通过一个简单的“状态转移方程” `current_sum = max(nums[i], current_sum + nums[i])`，我们就能在一次遍历中解决问题。



```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max_sum = nums[0];
        int curr_sum = nums[0];

        for(int i = 1; i < nums.size(); i++)
        {
            curr_sum = max(nums[i], curr_sum + nums[i]);
            max_sum = max(max_sum, curr_sum);
        }
        return max_sum;
    }
};
```

