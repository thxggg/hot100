### 第一阶段：暴力解法 - O(n²)

- **核心思路**：最直观的想法就是检查所有可能的连续子数组。
- **实现方法**：你第一时间就想到了用**两个嵌套的 `for` 循环**。外层循环确定“起点”，内层循环确定“终点”，然后计算这个区间的和。
- **遇到的瓶颈**：我们很快就分析出，这种 O(n²) 的方法涉及大量的重复计算，对于 `n` 较大的情况一定会超时。

### 第二阶段：思路的优化 - “前缀和”

- **核心问题**：如何避免重复计算子数组的和？
- **关键思路**：你准确地指出了“**前缀和**”这个强大的技巧。我们明确了计算任意子数组 `(i, j)` 和的公式：`sum(i, j) = prefix_sum[j] - prefix_sum[i-1]`。这为我们后续的优化铺平了道路。

### 第三阶段：最优解法 - “前缀和 + 哈希表”

- **思路的飞跃**：这是整个解法最精妙的地方。我们将目标 `sum(i, j) == k` 和前缀和公式结合，推导出了一个全新的关系式： `prefix_sum[i-1] = prefix_sum[j] - k`
- **关键洞察**：这个公式告诉我们，当我们在 `j` 位置算出了当前的前缀和 `current_sum` 时，我们**不需要回头**去检查所有 `i`。我们只需要“回头看”，**之前有多少个**前缀和的值等于 `current_sum - k`。
- **你的知识迁移**：在我的引导下，你准确地想到了使用**哈希表 (`map`)** 来解决这个“快速查找历史值出现次数”的问题。`map` 的 `{前缀和 -> 出现次数}` 结构完美地满足了我们的需求。

### 第四阶段：代码实现与关键知识点

- **算法流程**：我们最终确定了 O(n) 的高效算法流程：
  1. 遍历数组，同时计算当前的前缀和 `current_sum`。
  2. 在 `map` 中查找“搭档” (`current_sum - k`) 出现了几次，并累加到结果中。
  3. 将**当前**的 `current_sum` 存入 `map`，为后续的计算提供“历史记录”。
- **最重要的收获（两个关键细节）**：
  1. **初始化 `map`**：我们明白了为什么要在 `map` 中预先放入 `{0, 1}`。这是为了正确处理那些从数组开头就满足条件的子数组。
  2. **循环内的顺序**：我们理清了在循环内部，必须是**先查找搭档，再更新自己**的顺序。如果顺序反了，就会错误地把自己当作自己的“搭档”，导致计数错误。

### 总结

这道题是“前缀和”技巧和“哈希表”技巧的一次完美结合。它教会我们如何将一个看似需要两层循环的问题，通过巧妙的数学变换和数据结构，优化成只需一次遍历的 O(n) 解法。你通过这道题，对如何利用 `map` 来优化查找和计数问题，理解得更加深刻了。

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        map<int, int> prefix_sum_count;
        prefix_sum_count[0] = 1;
        int count = 0;
        int curr_sum = 0;
        for(int num : nums)
        {
            curr_sum += num;
            prefix_sum_count.count(curr_sum - k);
            count += prefix_sum_count[curr_sum -k];
            prefix_sum_count[curr_sum]++;
        }
        return count;
    }
};
```

